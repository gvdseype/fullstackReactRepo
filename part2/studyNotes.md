[TOC]

### Key-attribute

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <li>
            {note.content}
          </li>
        )}
      </ul>
    </div>
  )
}
```

Even though the application seems to be working, a warning appears in the console:

![fullstack content](https://fullstackopen.com/static/fbe2815380db6eb1be707011330d79e1/5a190/1a.png)

The list items, in this case the elements generated by the `map` method, must each have a unique key value: an attribute called `key`.

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <li key={note.id}>
            {note.content}
          </li>
        )}
      </ul>
    </div>
  )
}
```

Now that our `li` element has a unique key attribute, the error message disappears.

**React uses the key attributes of objects in an array to determine how to update the view generated by a component when the component is re-rendered.** 

Because of this, `map` is crucial for implementing arrays in components. 

When using a Component to return the desired format, you have to add the key attribute on the Component itself, and not on the element itself returned by the Component:

```javascript
const App = ({ notes }) => {
  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
    </div>
  )
}
```

### Modules

You can place Components in modules, seperate files which can be imported in the `App.js` file

A module file containing a component `Note`:

```javascript
import React from 'react'

const Note = ({ note }) => {
  return (
    <li>{note.content}</li>
  )
}

export default Note
```

Which needs to be imported in the `App.js` file:

```javascript
import Note from './components/Note'

const App = ({ notes }) => {
  // ...
}
```

### Map function

The `map` function can be used to generate React elements from an array object. 

```nav
notes.map(note => <li>{note.content}</li>)
```

Here the result is an array of `li` elements, which can be placed in `ul` tags. 

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => <li>{note.content}</li>)}
      </ul>
    </div>
  )
}
```

But because generating the `li` tags is done with JavaScript, it must be wrapped in curly braces in a JSX template just like all other JavaScript code. 

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => <li>key={note.id} {note.content}</li>)}
      </ul>
    </div>
  )
}
```

### Controlled component

A controlled component helps you access the data that is contained in the forms `input` element

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)
  const [newNote, setNewNote] = useState(
    'a new note...'
  ) 

  // ...

  const handleNoteChange = (event) => {
    console.log(event.target.value)
    setNewNote(event.target.value)
  }

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
      <form onSubmit={addNote}>
        <input
          value={newNote}
          onChange={handleNoteChange}
        />
        <button type="submit">save</button>
      </form>   
    </div>
  )
}
```

Adding a new note through an event handler could be done like this:

```javascript
const addNote = (event) => {
    event.preventDefault();
    const noteObject = {
      content: newNote,
      date: new Date().toISOString(),
      important: Math.random() < 0.5,
      id: notes.length + 1,
    }
    setNotes(notes.concat(noteObject))
    setNewNote('')
  }
```

The event handler also resets the value of the controlled input element by calling the `setNewNote` function of the `newNote` state. 

### Filtering Displayed Elements

Keeping track of which notes should be displayed can be managed by a piece of state that we can add to the `App` component. 

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)
  const [newNote, setNewNote] = useState('') 
  const [showAll, setShowAll] = useState(true)

  // ...

  const notesToShow = showAll
    ? notes
    : notes.filter(note => note.important === true)

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notesToShow.map(note =>
          <Note key={note.id} note={note} />
        )}
      </ul>
      // ...
    </div>
  )
}

```

The definition of the `notesToShow` variable uses a conditional statement. If the value of `showAll` is false, the variable `notesToShow` will only return the notes that are important (`true`), but if `showAll` is true, it will the unfiltered `notes` state. 

We can add functionality that enables users to toggle the `showAll` state of the application from the user interface:

```javascript
<div>
 <button onClick={() => setShowAll(!showAll)}>
   show {showAll ? 'important' : 'all' }
 </button>
</div>
```

### Setting up a server

There is a tool called JSON server that can act as a server. To install the server globally:

```
npm install -g json-server
```

From the root directory of the app, we can run the json-server using:

```
npx json-server --port 3001 --watch db.json
```

You can then navigate to `http://localhost:3001/notes` in the browser.

### Asynchronous requests

By registring an event handler to a `XHR` object representing an HTTP request, the JavaScript within the event handler will be called whenever the event is triggered. Therefore, the code does not execute synchronously 'from top to bottom', but does so asynchronously. JavaScript calls the event handler that was registered for the request at some point. 

JavaScript engines follow the asynchronous model, this requires all IO-operations (with some exceptions) to be executed as non-blocking. This means that code execution continues immediately after calling an IO function, without waiting for it to return. 

### Axios

The axios library works like fetch and can be installed via node packet manager, like this:

```
npm install axios
```

**`npm`** commands should always be run in the project root directory, which is where the package.json file can be found. This command will install Axios as one of the dependencies found in package.json. In addition, the command also downloaded the library code, which can be found in `node_modules` directory in the root. 

We can install `json-server` as a development dependency by executing the command:

```
npm install json-server --save-dev
```

and making a small addition to the scripts part of the package.json file:

```
{
  // ... 
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "server": "json-server -p3001 --watch db.json"
  },
}
```

After this, we can now start the json-server from the project root directory with the command:

```
npm run server
```

#### The difference between axios and json-server

```js
npm install axios
npm install json-server --save-dev
```

* Axios is installed as a runtime dependency of the application, because the execution of the program requires the existence of the library.
* Json-server was installed as a development dependency, since the program itself doesn't require it. It is used during software development. 

#### Axios and promises

To run json-server and your react simultaneously, you may need to use two terminal windows. One to keep json-server running and the other to run react-app. 

The library can be brought into use by the `import` statement:

```
import axios from 'axios'

const promise = axios.get('http://localhost:3001/notes')
console.log(promise)

const promise2 = axios.get('http://localhost:3001/foobar')
console.log(promise2)
```

![fullstack content](https://fullstackopen.com/static/823a2e7f414c99cb849a42470e4f372d/5a190/16b.png)

When the content of the file `index.js` changes, React does not always notice that automatically. We need to refresh the browser to see the changes. To make React notice the changes automatically, we can create a file named `.env` in the root directory of the project and add the line 

```
FAST_REFRESH=false
```

After which we need to restart the app for the applied changes to take effect. 

#### `get` method

Axios' method `get` returns a promise. 

*A Promise is an object representing the eventual completion or failure of an asynchronous operation*

In other words, a promise is an object that represents an asynchronous operation. A promise can have 3 different states:

1. The promise is *pending* : it means that the final value (one of the following two) is not available.
2. The promise is *fulfilled*: it means that the operation has been completed and the final value is available, which generally is a successful operation. This state is sometimes called `resolved`.
3. The promise is rejected: it means that an error prevented the final value from being determined, which generally represents a failed operation.

#### `then` method

If we want to access the result of the operation represented by the promise, we must register an event handler to the promise. This can be done with `then`:

```javascript
const promise = axios.get('http://localhost:3001/notes')

promise.then(response => {
  console.log(response)
})
```

The JavaScript runtime environment calls the callback function registed by the `then` method providing it with a `response` object as a parameter. The `response` object contains all the essential data related to the response of an HTTP GET request. This would include the returned *data*, *status code*, *headers*. 

Storing the promise object in a variable is unnecessary and it is more common to chain the `then` method to call the axios method, so that it follows it directly:

```javascript
axios
  .get('http://localhost:3001/notes')
  .then(response => {
    const notes = response.data
    console.log(notes)
  })
```

The data returned by the server is plain text, one long string.

The axios library is still able to parse the data into a JavaScript array, since the server has specified that the data format is `application/json; charset=utf-8` using the `content-type` header. 

```javascript
import ReactDOM from 'react-dom'
import App from './App'

import axios from 'axios'

axios.get('http://localhost:3001/notes').then(response => {
  const notes = response.data
  ReactDOM.render(
    <App notes={notes} />,
    document.getElementById('root')
  )
})
```

We can move the fetching of the data into the `App` component. 

### Effect-Hooks

*The effect hook lets you perform side effects on function components. Data fetching, setting up a subscription, manually changing the DOM in React components are all examples of side effects.*

```javascript
import { useState, useEffect } from 'react'
import axios from 'axios'
import Note from './components/Note'

const App = () => {
  const [notes, setNotes] = useState([])
  const [newNote, setNewNote] = useState('')
  const [showAll, setShowAll] = useState(true)

  useEffect(() => {
    console.log('effect')
    axios
      .get('http://localhost:3001/notes')
      .then(response => {
        console.log('promise fulfilled')
        setNotes(response.data)
      })
  }, [])
  console.log('render', notes.length, 'notes')

  // ...
}
```

The use effect hook takes two parameters:

```javascript
const hook = () => {
  console.log('effect')
  axios
    .get('http://localhost:3001/notes')
    .then(response => {
      console.log('promise fulfilled')
      setNotes(response.data)
    })
}

useEffect(hook, [])
```

1. The function or the effect itself. The effects run after every completed render, but you can choose to fire it only when certain values have changed.
2. The second parameter of `useEffect` is used to specify how often the effect is run. If the second parameter is an empty array, then the effect is only run along the first render of the component. 

### Structure

![fullstack content](https://fullstackopen.com/static/0e3766361ce9d08f0c4fdd39152cf493/5a190/18e.png)

- The real app gets the JavaScript from React dev server (runs with the command `npm start`)

  The dev-server transforms the JavaScript into a format understood by the browser. Among other things, it stitches together JavaScript from different files into on file. 

- The react app fetches the JSON formatted data from the json-server running on port 3001. 

### Sending Data to the Server

Sending data can be done like this:

```javascript
addNote = event => {
  event.preventDefault()
  const noteObject = {
    content: newNote,
    date: new Date(),
    important: Math.random() < 0.5,
  }

  axios
    .post('http://localhost:3001/notes', noteObject)
    .then(response => {
      console.log(response)
    })
}
```

The new note will not be rendered to the screen yet. This is because we did not update the state of the App component when we created the new note. This can be done by adding the following lines

```javascript
 axios
    .post('http://localhost:3001/notes', noteObject)
    .then(response => {
      setNotes(notes.concat(response.data))
      setNewNote('')
    })
}
```

Making a `POST` request within an event handler function works like this:

```javascript
const toggleImportanceOf = id => {
  const url = `http://localhost:3001/notes/${id}`
  const note = notes.find(n => n.id === id)
  const changedNote = { ...note, important: !note.important }

  axios.put(url, changedNote).then(response => {
    setNotes(notes.map(note => note.id !== id ? note : response.data))
  })
}
```

Explanation for `const changedNote = { ...note, important: !note.important }`:

`{...note}` creates a new object with copies of all properties from the `note` object. When adding properties inside the curly braces adter the spread object, here `{...note, important: true}`, then the value of the `important` property of the new object will be `true`. In our example the `important` property gets the negation of its previous value in the original object. We made a shallow copy, meaning that the values of the new object are the same as the values of the old object.

This allows us to leave the original intact by not mutating it. 

> **After this we are calling `setNotes` to update the new version of the `notes` array by providing a `map` callback. It will keep any note unchanged that does not have the same `id` as the `note id` we changed, and for the `note` in the `notes array` that does have the same id we replace it with `response.data.`**

```javascript
notes.map(note => note.id !== id ? note : response.data)
```



### Extracting communication with the backend into a seperate module

In the spirit of the `single responsibility principle`, it is wise to extract this communication to its own module. This module will sit in a seperate directory under `src`, called `services`. We add a file called `notes.js` in this directory:

```javascript
import axios from 'axios'
const baseUrl = 'http://localhost:3001/notes'

const getAll = () => {
  return axios.get(baseUrl)
}

const create = newObject => {
  return axios.post(baseUrl, newObject)
}

const update = (id, newObject) => {
  return axios.put(`${baseUrl}/${id}`, newObject)
}

export default { 
  getAll: getAll, 
  create: create, 
  update: update 
}
```

The module returns an object that has three functions, as its properties that deal with notes. The function directly returns the promises returned by the axios methods. 

We can import this module from the `App` component:

```javascript
import noteService from './services/notes'

const App = () => {
```

The functions of the module can be used directly with the imported variable `noteService` as follows:

```javascript
const App = () => {
  // ...

  useEffect(() => {
    noteService
      .getAll()
      .then(response => {
        setNotes(response.data)
      })
  }, [])

	const toggleImportanceOf = id => {
  const note = notes.find(n => n.id === id)
  const changedNote = { ...note, important: !note.important }

  noteService
    .update(id, changedNote)
    .then(response => {
    	setNotes(notes.map(note => note.id !== id ? note : response.data))
  	})
  }

  const addNote = (event) => {
    event.preventDefault()
    const noteObject = {
      content: newNote,
      date: new Date().toISOString(),
      important: Math.random() > 0.5
    }

    noteService
      .create(noteObject)
      .then(response => {
      setNotes(notes.concat(response.data))
      setNewNote('')
    })
  }

  // ...
}

export default App
```

The module would be much nicer to use if, instead of the entire HTTP response, we would only get the response data. Using the module would then look like this:

```javascript
noteService
  .getAll()
  .then(initialNotes => {
    setNotes(initialNotes)
  })
```

To be able to use this code, we need to change things in the module:

```javascript
import axios from 'axios'
const baseUrl = 'http://localhost:3001/notes'

const getAll = () => {
  const request = axios.get(baseUrl)
  return request.then(response => response.data)
}

const create = newObject => {
  const request = axios.post(baseUrl, newObject)
  return request.then(response => response.data)
}

const update = (id, newObject) => {
  const request = axios.put(`${baseUrl}/${id}`, newObject)
  return request.then(response => response.data)
}

export default { 
  getAll: getAll, 
  create: create, 
  update: update 
}
```

We no longer return the promise returned by axios directly, instead we assign the promise to the `request` variable and call its `then` method:

```javascript
const getAll = () => {
  const request = axios.get(baseUrl)
  return request.then(response => response.data)
}
```

After defining the parameter of the `then` method to directly return `response.data`, we have gotten the `getAll` function to work like we wanted it to. When the HTTP request is successful, the promise returns the data sent back in the response from the backend. 

This means we have to update the `App` component to work with the changes we made in the module. Specifically, we need to fix the callback function given as parameter to the `noteService` method, so that they use the directly returned `response.data`. 

```javascript
  useEffect(() => {
    noteService
      .getAll()
      .then(initialNotes => {
        setNotes(initialNotes)
      })
  }, [])
```

```javascript
 noteService
      .update(id, changedNote)
      .then(returnedNote => {
        setNotes(notes.map(note => note.id !== id ? note : returnedNote))
      })
```

```javascript
noteService
      .create(noteObject)
      .then(returnedNote => {
        setNotes(notes.concat(returnedNote))
        setNewNote('')
      })
```

In the first function we just set the notes to our `initialNotes`. In the second function we update the `setNotes` by replacing it with the mapped version of the `notes` array. The third function we add a new note by setting a copy of the `notes` array and pushing the new note via the `concat` method. 

### Clearer syntax for defining object literals

The module defining note related services currently exports an object with the properties `getAll`, `create` and `update` that are assigned to functions for handling notes. 

Instead of exporting this

```javascript
export default { 
  getAll: getAll, 
  create: create, 
  update: update 
}
```

We can export a more compact syntax

```javascript
export default { 
  getAll, 
  create, 
  update 
}
```

Or simply `export default { getAll, create, update }`

### Promises and Errors

The rejection of a promise is handled by providing the `then` method with a second callback function, which is called in the situation where the promise is rejected.

The common way to handle rejected promises is to use the catch method:

```javascript
axios
  .get('http://example.com/probably_will_fail')
  .then(response => {
    console.log('success!')
  })
  .catch(error => {
    console.log('fail')
  })
```

We can also create a promise chain:

```javascript
axios
  .put(`${baseUrl}/${id}`, newObject)
  .then(response => response.data)
  .then(changedNote => {
    // ...
  })
```

We can add a feature and register an error handler in the `App` component:

```javascript
const toggleImportanceOf = id => {
  const note = notes.find(n => n.id === id)
  const changedNote = { ...note, important: !note.important }

  noteService
    .update(id, changedNote).then(returnedNote => {
      setNotes(notes.map(note => note.id !== id ? note : returnedNote))
    })
    .catch(error => {
      alert(
        `the note '${note.content}' was already deleted from server`
      )
      setNotes(notes.filter(n => n.id !== id))
    })
}
```


[TOC]

### Key-attribute

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <li>
            {note.content}
          </li>
        )}
      </ul>
    </div>
  )
}
```

Even though the application seems to be working, a warning appears in the console:

![fullstack content](https://fullstackopen.com/static/fbe2815380db6eb1be707011330d79e1/5a190/1a.png)

The list items, in this case the elements generated by the `map` method, must each have a unique key value: an attribute called `key`.

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <li key={note.id}>
            {note.content}
          </li>
        )}
      </ul>
    </div>
  )
}
```

Now that our `li` element has a unique key attribute, the error message disappears.

**React uses the key attributes of objects in an array to determine how to update the view generated by a component when the component is re-rendered.** 

Because of this, `map` is crucial for implementing arrays in components. 

When using a Component to return the desired format, you have to add the key attribute on the Component itself, and not on the element itself returned by the Component:

```javascript
const App = ({ notes }) => {
  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
    </div>
  )
}
```

### Modules

You can place Components in modules, seperate files which can be imported in the `App.js` file

A module file containing a component `Note`:

```javascript
import React from 'react'

const Note = ({ note }) => {
  return (
    <li>{note.content}</li>
  )
}

export default Note
```

Which needs to be imported in the `App.js` file:

```javascript
import Note from './components/Note'

const App = ({ notes }) => {
  // ...
}
```

### Map function

The `map` function can be used to generate React elements from an array object. 

```nav
notes.map(note => <li>{note.content}</li>)
```

Here the result is an array of `li` elements, which can be placed in `ul` tags. 

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => <li>{note.content}</li>)}
      </ul>
    </div>
  )
}
```

But because generating the `li` tags is done with JavaScript, it must be wrapped in curly braces in a JSX template just like all other JavaScript code. 

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => <li>key={note.id} {note.content}</li>)}
      </ul>
    </div>
  )
}
```

### Controlled component

A controlled component helps you access the data that is contained in the forms `input` element

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)
  const [newNote, setNewNote] = useState(
    'a new note...'
  ) 

  // ...

  const handleNoteChange = (event) => {
    console.log(event.target.value)
    setNewNote(event.target.value)
  }

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
      <form onSubmit={addNote}>
        <input
          value={newNote}
          onChange={handleNoteChange}
        />
        <button type="submit">save</button>
      </form>   
    </div>
  )
}
```

Adding a new note through an event handler could be done like this:

```javascript
const addNote = (event) => {
    event.preventDefault();
    const noteObject = {
      content: newNote,
      date: new Date().toISOString(),
      important: Math.random() < 0.5,
      id: notes.length + 1,
    }
    setNotes(notes.concat(noteObject))
    setNewNote('')
  }
```

The event handler also resets the value of the controlled input element by calling the `setNewNote` function of the `newNote` state. 

### Filtering Displayed Elements

Keeping track of which notes should be displayed can be managed by a piece of state that we can add to the `App` component. 

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)
  const [newNote, setNewNote] = useState('') 
  const [showAll, setShowAll] = useState(true)

  // ...

  const notesToShow = showAll
    ? notes
    : notes.filter(note => note.important === true)

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notesToShow.map(note =>
          <Note key={note.id} note={note} />
        )}
      </ul>
      // ...
    </div>
  )
}

```

The definition of the `notesToShow` variable uses a conditional statement. If the value of `showAll` is false, the variable `notesToShow` will only return the notes that are important (`true`), but if `showAll` is true, it will the unfiltered `notes` state. 

We can add functionality that enables users to toggle the `showAll` state of the application from the user interface:

```javascript
<div>
 <button onClick={() => setShowAll(!showAll)}>
   show {showAll ? 'important' : 'all' }
 </button>
</div>
```

